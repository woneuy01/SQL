SELECT * FROM CUSTOMER_ORDER
WHERE ORDER_DATE = (SELECT MAX(ORDER_DATE) FROM CUSTOMER_ORDER)

----------------------------
SELECT CUSTOMER_ORDER_ID,
CUSTOMER_ID,
ORDER_DATE,
PRODUCT_ID,
QUANTITY

FROM CUSTOMER_ORDER

WHERE CUSTOMER_ID IN (
    SELECT CUSTOMER_ID
    FROM CUSTOMER
    WHERE STATE = 'TX'
    )
    
------------------------------------
-- IT IS NOT EFFICIENT BUT WE CAN DO THIS
--c2 is inner table c1 is ourter table
SELECT CUSTOMER_ORDER_ID, 
CUSTOMER_ID,
ORDER_DATE,
PRODUCT_ID,
QUANTITY,
(
    SELECT AVG(QUANTITY)
    FROM CUSTOMER_ORDER c2
    WHERE c2.CUSTOMER_ID = c1.CUSTOMER_ID
    AND c2.PRODUCT_ID = c1.PRODUCT_ID
    ) AS AVG_QUANTITY
FROM CUSTOMER_ORDER c1

이렇게 하는 것보다 join으로 아래와 같이 avg 계산하는 하는 것이 더 효울적
-----------------------------------------
SELECT CUSTOMER_ORDER_ID,
CUSTOMER_ORDER.CUSTOMER_ID,
ORDER_DATE,
CUSTOMER_ORDER.PRODUCT_ID,
QUANTITY,
cust_avgs.avg_qty

FROM CUSTOMER_ORDER

INNER JOIN
(
    SELECT CUSTOMER_ID,
    PRODUCT_ID,
    AVG(QUANTITY) AS avg_qty
    FROM CUSTOMER_ORDER
    GROUP BY 1,2
) cust_avgs

ON CUSTOMER_ORDER.CUSTOMER_ID = cust_avgs.CUSTOMER_ID
AND CUSTOMER_ORDER.PRODUCT_ID = cust_avgs.PRODUCT_ID

이것보다 아래와 같이 CTE로 먼저 평균을 정의하고 하는게 더 깔끔하다.
--COMMON TABLE EXPRESSION-------------------
WITH CUST_AVGS AS (
    SELECT CUSTOMER_ID,
    PRODUCT_ID,
    AVG(QUANTITY) AS AVG_QTY
    FROM CUSTOMER_ORDER
    GROUP BY 1,2
)
SELECT CUSTOMER_ORDER_ID,
CUSTOMER_ORDER.CUSTOMER_ID,
ORDER_DATE,
CUSTOMER_ORDER.PRODUCT_ID,
QUANTITY,
AVG_QTY

FROM CUSTOMER_ORDER INNER JOIN CUST_AVGS

ON CUSTOMER_ORDER.CUSTOMER_ID = CUST_AVGS.CUSTOMER_ID
AND CUSTOMER_ORDER.PRODUCT_ID = CUST_AVGS.PRODUCT_ID

---TWO COMMON TABLES (CTE)---------------------------
--chain CTE twice---
WITH TX_CUSTOMERS AS 
(
SELECT * FROM CUSTOMER
WHERE STATE = 'TX'
),
TX_ORDERS AS 
(
SELECT * FROM CUSTOMER_ORDER
WHERE CUSTOMER_ID IN (SELECT CUSTOMER_ID FROM TX_CUSTOMERS)
--GET CUSTOMER ID ONLY IN TX_CUSTOMERS(USING PREVIOUS COMMON TABLE)
)

SELECT * FROM TX_ORDERS INNER JOIN TX_CUSTOMERS
ON TX_ORDERS.CUSTOMER_ID = TX_CUSTOMERS.CUSTOMER_ID

--UNION --WITH EXACT SAME FIELD AND NAME
SELECT
'FEB' AS MONTH,
PRODUCT.PRODUCT_ID,
PRODUCT_NAME,
SUM(PRICE * QUANTITY) AS REV
FROM PRODUCT LEFT JOIN CUSTOMER_ORDER
ON PRODUCT.PRODUCT_ID = CUSTOMER_ORDER.PRODUCT_ID

WHERE ORDER_DATE BETWEEN '2017-02-01' AND '2017-02-28'
GROUP BY 1,2,3

UNION ALL  -- OR UNION

SELECT
'MAR' AS MONTH,
PRODUCT.PRODUCT_ID,
PRODUCT_NAME,
SUM(PRICE * QUANTITY) AS REV
FROM PRODUCT LEFT JOIN CUSTOMER_ORDER
ON PRODUCT.PRODUCT_ID = CUSTOMER_ORDER.PRODUCT_ID

WHERE ORDER_DATE BETWEEN '2017-03-01' AND '2017-03-31'
GROUP BY 1,2,3

----CASE IS BETTER THAN UNION, TRY TO AVOID UNION
SELECT
CASE
    WHEN ORDER_DATE BETWEEN '2017-02-01' AND '2017-02-28' THEN 'FEB'
    WHEN ORDER_DATE BETWEEN '2017-03-01' AND  '2017-03-31' THEN 'MAR'
END AS MONTH,

PRODUCT.PRODUCT_ID,
PRODUCT_NAME,
SUM(PRICE*QUANTITY) AS REV

FROM PRODUCT LEFT JOIN CUSTOMER_ORDER
ON PRODUCT.PRODUCT_ID = CUSTOMER_ORDER.PRODUCT_ID

WHERE ORDER_DATE BETWEEN '2017-02-01' AND '2017-03-31'
GROUP BY 1,2,3

---------------------------------------------------------------
--REGULAR EXPRESSION

SELECT 'TX' REGEXP 'TX' -- TRUE

[\^$.|?*+()

SELECT '$181.12' REGEXP '\$181\.12';   --TRUE

SELECT 'TX' REGEXP '[A-Z][A-Z]'; -- TRUE
SELECT '45' REGEXP '[A-Z][A-Z]'; --FALSE
SELECT 'T2' REGEXP '[A-Z][0-3]'; -- TRUE
SELECT 'T9' REGEXP '[A-Z0-9][A-Za-z0-9]';  -- TRUE


--RANGE--
SELECT 'TX' REGEXP '[A-Z][A-Z][A-Z]' ; --FALSE
SELECT 'ASU' REGEXP '[A-Z][A-Z][A-Z]' ; --TRUE

-- SPECIFY CERTAIN CHARACTERS
SELECT 'A6' REGEXP '[ATUX][469]';  --A,OR,U,X
SELECT 'B8' REGEXP '[ATUX][469]';

--NEGATE CHARACTER RANGE
SELECT 'A6' REGEXP '[^ATUX][^469]'; -- FALSE
SELECT 'B8' REGEXP '[^ATUX][^469]'; -- TRUE

-- PARTIAL MATCH
SELECT 'SMU' REGEXP '[A-Z][A-Z]'; -- TRUE SINCE REGULAR EXPRESSION LOOK FOR PARTIAL MATCH AS WELL
--TO BE MORE SPECIFIC
SELECT 'SMU' REGEXP '^[A-Z][A-Z]$'; -- FALSE  ^START WITH, $ END WITH

SELECT '9FN' REGEXP '^[0-9][A-Z]';   --TRUE PARTIAL MATCH
SELECT 'RFX' REGEXP '^[0-9][A-Z]';  --FALSE

-- REPITOR--
SELECT 'ASU' REGEXP '^[A-Z][A-Z][A-Z]$' ;-- TRUE
SELECT 'ASU' REGEXP '^[A-Z]{3}  -- TRUE

-- MIN AND MAX LENGTH
SELECT 'AS' REGEXP '^[A-Z]{2,3}$' --TRUE; [A-Z] MIN 2 MAX 3 TIMES
SELECT 'ASASDFADFADSFASDF' REGEXP '^[A-Z]{2,}$' --TRUE; [A-Z] MIN 2 TO INFINITE

-- '+' IS THE SAME MEANING {1,} MINIMUM 1 REPITITION
SELECT 'ASASDFADFADSFASDF' REGEXP '^[A-Z0-9]+$' --TRUE; 

SELECT ' ' REGEXP '^[A-Z0-9]{0,}'; --TRUE

SELECT '9FX' REGEXP '^[0-9]{0,1}[A-Z]{2}$';  --TRUE

SELECT 'FX' REGEXP '^[0-9]{0,1}[A-Z]{2}$';  --TRUE

SELECT'ADFAS-3453434-ASDGAD' REGEXP '^[A-Z]+-[0-9]+-[A-Z]+$'  -- TRUE

--- '.' WILD CARD MATCH ANY SINGLE CHARACTER
SELECT 'A-3' REGEXP ',,,' -- TRUE MATCH ANY 3 CHARACTERS
SELECT 'A-3' REGEXP ',{3}' -- TRUE

SELECT 'A-3' REGEXP '.*'; --TRUE ANY CHARACTOER . REPEAT* MEANS MATCH EVERYTHING

-- GROUPING
SELECT '181.12.12' REGEXP '^[0-9]+(\.[0-9]{2})?$' --TRUE  REPEAT THIS GROUP PART (\.[0-9]{2})

SELECT 'ADSFA/1234/ASDFA/134324/ASDFASD/23432' REGEXP '^([A-Z]+/[0-9]+/?)+$';  --TRUE

--- OR |'
SELECT 'ALPHA' REGEXP '^(FOXTROT|ZULU|ALPHA|TANGO)$' --TRUE

SELECT * FROM CUSTOMER 
WHERE ADDRESS REGEXP '^[0-9]{3,4} .*$'  --WANT 3 TO 4 DIGIT AND SPACE AND REST OF THEM i DON'T CARE

SELECT * FROM CUSTOMER 
WHERE ADDRESS REGEXP '^[0-9]{3,4}\S'      -- \S PLACE HOLDER FOR SPACE

SELECT * FROM CUSTOEMR_ORDER

--VOLATILE TABLE OR TEMP TALBE : CREATE TEMPERARY OR DB AS LONG AS THIS SESSION IS ON CONNECTED
CREATE TEMP TABLE DISCOUNT (
    CUSTOMER_ID_REGEX VARCHAR(20) NOT NULL DEFAULT ('.*'), --  '.* ' WILL MATCH EVERYTHING
    PRODUCT_ID_REGEX VARCHAR(20) NOT NULL DEFAULT ('.*'),
    PRODUCT_GROUP_REGEX VARCHAR(30) NOT NULL DEFAULT('.*'),
    STATE_REGEX VHARCHAR(30) NOT NULL DEFAULT('.*'),
    DISCOUNT_RATE DOUBLE NOT NULL
    );

INSERT INTO DISCOUNT (STATE_REGEX, DISCOUNT_RATE) VALUES ('LA|OK', 0.20);
INSERT INTO DISCOUNT (PRODUCT_GROUP_REGEX, STATE_REGEX, DISCOUNT_RATE) VALUES ('BETA|GAMMA','TX', 0.10);
INSERT INTO DISCOUNT (PRODUCT_ID_REGEX, CUSTOMER_ID_REGEX, DISCOUNT_RATE) VALUES ('^[379]$', '^(1|6|12)$', 0.30);

SELECT * FROM DISCOUNT
---------------------------------------------------------------------------------
SELECT CUSTOMER_ORDER.*,
PRICE,
DISCOUNT_RATE,
PRICE * (1 - DISCOUNT_RATE) AS DISCOUNTED_PRICE

FROM CUSTOMER_ORDER
INNER JOIN CUSTOMER
ON CUSTOMER_ORDER.CUSTOMER_ID = CUSTOMER.CUSTOMER_ID

INNER JOIN PRODUCT
ON CUSTOMER_ORDER.PRODUCT_ID = PRODUCT.PRODUCT_ID

LEFT JOIN DISCOUNT
ON CUSTOMER_ORDER.CUSTOMER_ID REGEXP DISCOUNT.CUSTOMER_ID_REGEX --qualifying on the regular expressions for each respective field
AND CUSTOMER_ORDER.PRODUCT_ID REGEXP DISCOUNT.PRODUCT_ID_REGEX
AND PRODUCT.PRODUCT_GROUP REGEXP DISCOUNT.PRODUCT_GROUP_REGEX
AND CUSTOMER.STATE REGEXP DISCOUNT.STATE_REGEX

WHERE ORDER_DATE BETWEEN '2017-03-26' AND '2017-03-31'

-----------
--Note you can also create a temporary (or permanent) table from a SELECT query. 
--This is helpful to persist expensive query results and reuse it multiple times 
--during a session. SQLite is a bit more convoluted to do this than other platforms:
CREATE TEMP TABLE ORDER_TOTALS_BY_DATE AS
WITH ORDER_TOTALS_BY_DATE AS (
    SELECT ORDER_DATE,
    SUM(QUANTITY) AS TOTAL_QUANTITY
    FROM CUSTOMER_ORDER
    GROUP BY 1
)
SELECT * FROM ORDER_TOTALS_BY_DATE













